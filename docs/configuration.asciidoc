
== Configuration

Almost every aspect of the client is configurable.  Most users will only need to configure a few parameters to suit
their needs, but it is possible to completely replace much of the internals if required.

Custom configuration is accomplished before the client is instantiated, through the ClientBuilder helper object.
We'll walk through all the configuration options and show sample code to replace the various components.

=== Host Configuration

The most common configuration is telling the client about your cluster: how many nodes, their addresses and ports.  If
no hosts are specified, the client will attempt to connect to `localhost:9200`.

This behavior can be changed by using the `setHosts()` method on `ClientBuilder`.  The method accepts an array of values,
each entry corresponding to one node in your cluster.  The format of the host can vary, depending on your needs (ip vs
hostname, port, ssl, etc)

[source,php]
----
$hosts = [
    '192.168.1.1:9200',         // IP + Port
    '192.168.1.2',              // Just IP
    'mydomain.server.com:9201', // Domain + Port
    'mydomain2.server.com',     // Just Domain
    'https://localhost',        // SSL to localhost
    'https://192.168.1.3:9200'  // SSL to IP + Port
];
$client = ClientBuilder::create()           // Instantiate a new ClientBuilder
                    ->setHosts($hosts)      // Set the hosts
                    ->build();              // Build the client object
----

Notice that the `ClientBuilder` object allows chaining method calls for brevity.  It is also possible to call the methods
individually:

[source,php]
----
$hosts = [
    '192.168.1.1:9200',         // IP + Port
    '192.168.1.2',              // Just IP
    'mydomain.server.com:9201', // Domain + Port
    'mydomain2.server.com',     // Just Domain
    'https://localhost',        // SSL to localhost
    'https://192.168.1.3:9200'  // SSL to IP + Port
];
$clientBuilder = ClientBuilder::create();   // Instantiate a new ClientBuilder
$clientBuilder->setHosts($hosts);           // Set the hosts
$client = $clientBuilder->build();          // Build the client object
----

=== Authorization and Encryption

For details about HTTP Authorization and SSL encryption, please see link:_security.html[Authorization and SSL].

=== Set retries

By default, the client will retry `n` times, where `n = number of nodes` in your cluster.  A retry is only performed
if the operation results in a "hard" exception: connection refusal, connection timeout, DNS lookup timeout, etc.  4xx and
5xx errors are not considered retry'able events, since the node returns an operational response.

If you would like to disable retries, or change the number, you can do so with the `setRetries()` method:

[source,php]
----------------------------

$client = ClientBuilder::create()
                    ->setRetries(2)
                    ->build();
----------------------------

When the client runs out of retries, it will throw the last exception that it received.  For example, if you have ten
alive nodes, and `setRetries(5)`, the client will attempt to execute the command up to five times.  If all five nodes
result in a connection timeout (for example), the client will throw an `OperationTimeoutException`.  Depending on the
Connection Pool being used, these nodes may also be marked dead.


[[enabling_logger]]
=== Enabling the Logger
Elasticsearch-PHP supports logging, but it is not enabled by default for performance reasons.  If you wish to enable logging,
you need to select a logging implementation, install it, then enable the logger in the Client.  The recommended logger
is https://github.com/Seldaek/monolog[Monolog], but any logger that implements the `PSR/Log` interface will work.

You might have noticed that Monolog was suggested during installation.  To begin using Monolog, add it to your `composer.json`:

[source,json]
----------------------------
{
    "require": {
        ...
        "elasticsearch/elasticsearch" : "^2.0",
        "monolog/monolog": "^1.0"
    }
}
----------------------------

And then update your composer installation:

[source,shell]
----------------------------
php composer.phar update
----------------------------

Once Monolog (or another logger) is installed, you need to create a log object and inject it into the client.

[source,php]
----
use Monolog\Logger;
use Monolog\Handler\StreamHandler;

$logger = new Logger('name');
$logger->pushHandler(new StreamHandler('path/to/your.log', Logger::WARNING));

$client = ClientBuilder::create()       // Instantiate a new ClientBuilder
            ->setLogger($logger)        // Set your custom logger
            ->build();                  // Build the client object
----


=== Configure the HTTP Client

Elasticsearch-PHP uses an interchangeable HTTP transport layer called http://docs.php-http.org/en/latest/httplug/introduction.html[HTTPlug].
This allows the client to construct a PSR7 HTTP Request, then pass it to the transport layer to execute.
The actual execution details are hidden from the client and modular, so that you can choose from several HTTP clients
depending on your needs.

By default it will try to find an `HttpAsyncClient` with helps of the http://docs.php-http.org/en/latest/discovery.html[discovery system]

You can configure the HTTP Client in the builder:

[source,php]
----
use GuzzleHttp\Client as GuzzleClient;
use Http\Adapter\Guzzle6\Client as GuzzleAdapter;

$config = [
    // Config params of Guzzle6
];

$httpAsyncClient = new GuzzleAdapter(new GuzzleClient($config));
$client = ClientBuilder::create()
            ->setHttpAsyncClient($httpAsyncClient)
            ->build();
----

For details on creating or using an HttpAsyncClient, please see http://docs.php-http.org/en/latest/clients.html[HTTPlug Documentation]

=== Setting the Client Pool

The connection pool manages the logic that decides which connection should be used for the next API request.
There are several strategies that you can choose from. It can be changed via the `setClientPoolStrategy()` method:

[source,php]
----
use Http\Client\Common\HttpClientPool\LeastUsedClientPool;

$client = ClientBuilder::create()
            ->setClientPoolStrategy(LeastUsedClientPool::class)
            ->build();
----

For more details, please see the dedicated page on http://docs.php-http.org/en/latest/components/client-common.html#httpclientpool[HTTPlug].


=== Setting the Serializer

Requests are given to the client in the form of associative arrays, but Elasticsearch expects JSON.  The Serializer's
job is to serialize PHP objects into JSON.  It also de-serializes JSON back into PHP arrays.  This seems trivial, but
there are a few edgecases which make it useful for the serializer to remain modular.

The majority of people will never need to change the default serializer (`SmartSerializer`), but if you need to,
it can be done via the `setSerializer()` method:

[source,php]
----
$serializer = '\Elasticsearch\Serializers\SmartSerializer';
$client = ClientBuilder::create()
            ->setSerializer($serializer)
            ->build();
----

For more details, please see the dedicated page on link:_serializers.html[configuring serializers].

=== Set the Endpoint closure

The client uses an Endpoint closure to dispatch API requests to the correct Endpoint object.  A namespace object will
construct a new Endpoint via this closure, which means this is a handy location if you wish to extend the available set
of API endpoints available

For example, we could add a new endpoint like so:

[source,php]
----

$transport = $this->transport;
$serializer = $this->serializer;

$newEndpoint = function ($class) use ($transport, $serializer) {
    if ($class == 'SuperSearch') {
        return new MyProject\SuperSearch($transport);
    } else {
        // Default handler
        $fullPath = '\\Elasticsearch\\Endpoints\\' . $class;
        if ($class === 'Bulk' || $class === 'Msearch' || $class === 'MPercolate') {
            return new $fullPath($transport, $serializer);
        } else {
            return new $fullPath($transport);
        }
    }
};

$client = ClientBuilder::create()
            ->setEndpoint($newEndpoint)
            ->build();
----

Obviously, by doing this you take responsibility that all existing endpoints still function correctly.  And you also
assume the responsibility of correctly wiring the Transport and Serializer into each endpoint.


=== Building the client from a configuration hash

To help ease automated building of the client, all configurations can be provided in a setting
hash instead of calling the individual methods directly.  This functionality is exposed through
the `ClientBuilder::FromConfig()` static method, which accepts an array of configurations
and returns a fully built client.

Array keys correspond to the method name, e.g. `retries` key corresponds to `setRetries()` method.


[source,php]
----
$params = [
    'hosts' => [
        'localhost:9200'
    ],
    'retries' => 2,
    'httpAsyncClient' => new GuzzleAdapter(new GuzzleClient([]))
];
$client = ClientBuilder::fromConfig($params);
----


Unknown parameters will throw an exception, to help the user find potential problems.
If this behavior is not desired (e.g. you are using the hash for other purposes, and may have
keys unrelated to the Elasticsearch client), you can set $quiet = true in fromConfig() to
silence the exceptions.

[source,php]
----
$params = [
    'hosts' => [
        'localhost:9200'
    ],
    'retries' => 2,
    'imNotReal' => 5
];

// Set $quiet to true to ignore the unknown `imNotReal` key
$client = ClientBuilder::fromConfig($params, true);
----
