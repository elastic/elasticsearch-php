[[connceting]]
== Connecting

This page contains the information you need to connect and use the Client with 
{es}.

**On this page**

* <<authentication, Authentication options>>
* <<client-usage, Using the client>>


[discrete]
[[authentication]]
=== Authentication

This section contains code snippets to show you how to connect to various {es} 
providers.

[discrete]
[[auth-ec]]
==== Elastic Cloud

You can connect to https://www.elastic.co/cloud/[Elastic Cloud] using an **API key**
and a **Cloud ID**:

[source,php]
----
$client = ClientBuilder::create()
   ->setElasticCloudId('<cloud-id>')
   ->setApiKey('<api-key>')
   ->build();
----

Where <cloud-id> and <api-key> can be retrieved using the Elastic Cloud web UI.

You can get the `Cloud ID` from the `My deployment` page of your dashboard (see the red
rectangle reported in the screenshot).

image::images/cloud_id.png[alt="Elastic Cloud ID",align="center"]

You can generate an `API key` in the `Management` page under the section `Security`.

image::images/create_api_key.png[alt="Create API key",align="center"]

When you click on `Create API key` button you can choose a name and set the other
options (eg. restrict privileges, expire after time, etc).

image::images/api_key_name.png[alt="Choose an API name",align="center"]

After this step you will get the `API key`in the API keys page. 

image::images/cloud_api_key.png[alt="Cloud API key",align="center"]

**IMPORTANT**: you need to copy and store the `API key`in a secure place, since you will not
be able to view it again in Elastic Cloud.


[discrete]
[[auth-http]]
==== HTTPS Authentication

{es} 8.0 offers https://www.elastic.co/blog/introducing-simplified-elastic-stack-security[security by default],
that means it uses https://en.wikipedia.org/wiki/Transport_Layer_Security[TLS]
for protect the communication between client and server.

In order to configure `elasticsearch-php` for connecting to {es} 8.0 we
need to have the certificate authority file (CA).

You can install {es} in different ways, for instance using https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html[Docker]
you need to execute the followind command:

[source,shell]
--------------------------
docker pull docker.elastic.co/elasticsearch/elasticsearch:8.0.1
--------------------------

Once you have the docker image installed you can execute {es},
for instance using a single-node cluster configuration, as follows:

[source,shell]
--------------------------
docker network create elastic
docker run --name es01 --net elastic -p 9200:9200 -p 9300:9300 -it docker.elastic.co/elasticsearch/elasticsearch:8.0.1
--------------------------

This command creates an `elastic` Docker network and start {es}
using the port `9200` (default).

When you run the docker imnage a password is generated for the `elastic` user
and it's printed to the terminal (you might need to scroll back a bit in the terminal
to view it). You have to copy it since we will need to connect to {es}.

Now that {es} is running we can get the `http_ca.crt` file certificate.
We need to copy it from the docker instance, using the following command:

[source,shell]
--------------------------
docker cp es01:/usr/share/elasticsearch/config/certs/http_ca.crt .
--------------------------

Once we have the `http_ca.crt` certificate and the `password`, copied during the
start of {es} , we can use it to connect with `elasticsearch-php`
as follows:

[source,php]
--------------------------
$client = ClientBuilder::create()
    ->setHosts(['https://localhost:9200'])
    ->setBasicAuthentication('elastic', 'password copied during Elasticsearch start')
    ->setCABundle('path/to/http_ca.crt')
    ->build();
--------------------------

For more information about the Docker configuration of Elasticsearch you can
read the official documentation https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html[here].


[discrete]
[[client-usage]]
=== Usage 

This section is a crash-course overview of the client and its syntax. If you 
are familiar with {es}, you'll notice that the methods are named just like REST 
endpoints.

You may also notice that the client is configured in a manner that facilitates 
easy discovery via your IDE. All core actions are available under the `$client` 
object (indexing, searching, getting, etc). Index and cluster management are 
located under the `$client->indices()` and `$client->cluster()` objects, 
respectively.


[discrete]
==== Indexing a document

In elasticsearch-php, almost everything is configured by associative arrays. The 
REST endpoint, body and optional parameters - everything is an associative 
array.

To index a document, we need to specify three pieces of information: index, id 
and a document body. This is done by constructing an associative array of 
key:value pairs. The request body is itself an associative array with key:value 
pairs corresponding to the data in your document:

[source,php]
----------------------------
$params = [
    'index' => 'my_index',
    'id'    => 'my_id',
    'body'  => ['testField' => 'abc']
];

$response = $client->index($params);
print_r($response->asArray());
----------------------------

The response that you get back indicates that the document was created in the 
index that you specified. The `$response` is an object of `Elastic\Elasticsearch\Response\Elasticsearch`
class that implements `ElasticsearchInterface`, PSR-7 https://www.php-fig.org/psr/psr-7/#33-psrhttpmessageresponseinterface[ResponseInterface]
and https://www.php.net/manual/en/class.arrayaccess.php[ArrayAccess].

This means the `$response` is a https://www.php-fig.org/psr/psr-7/[PSR-7]
object:

[source,php]
----------------------------
echo $response->getStatusCode(); // 200
echo (string) $response->getBody(); // Response body in JSON
----------------------------

and also an "array", meaning you can access the response body as an
associative array, as follows:

[source,php]
----------------------------
echo $response['version']['number']; // 8.0.0

var_dump($response->asArray());  // response body content as array
----------------------------

Moreover, you can access the response body as object, string or bool:


[source,php]
----------------------------
echo $response->version->number; // 8.0.0

var_dump($response->asObject()); // response body content as object
var_dump($response->asString()); // response body as string (JSON)
var_dump($response->asBool());   // true if HTTP response code between 200 and 300
----------------------------


[discrete]
==== Getting a document

Let's get the document that we just indexed. This returns the document:

[source,php]
----------------------------
$params = [
    'index' => 'my_index',
    'id'    => 'my_id'
];

$response = $client->get($params);
print_r($response->asArray());
----------------------------

The response contains metadata such as index, version, and so on as well as a 
`_source` field, which is the original document you sent to {es}.

[source,php]
----------------------------
Array
(
    [_index] => my_index
    [_type] => _doc
    [_id] => my_id
    [_version] => 1
    [found] => 1
    [_source] => Array
        (
            [testField] => abc
        )

)
----------------------------


[discrete]
==== Searching for a document

Searching is a hallmark of {es}, so let's perform a search. We are going to use 
the `match` query as a demonstration:

[source,php]
----------------------------
$params = [
    'index' => 'my_index',
    'body'  => [
        'query' => [
            'match' => [
                'testField' => 'abc'
            ]
        ]
    ]
];

$response = $client->search($params);
print_r($response->asArray());
----------------------------

The response here is different from the previous ones. You can see metadata 
(`took`, `timed_out`, etc.) and an array named `hits`. This represents your 
search results. Inside of `hits` is another array named `hits`, which contains 
individual search results:

[source,php]
----------------------------
Array
(
    [took] => 1
    [timed_out] =>
    [_shards] => Array
        (
            [total] => 5
            [successful] => 5
            [failed] => 0
        )

    [hits] => Array
        (
            [total] => 1
            [max_score] => 0.30685282
            [hits] => Array
                (
                    [0] => Array
                        (
                            [_index] => my_index
                            [_type] => _doc
                            [_id] => my_id
                            [_score] => 0.30685282
                            [_source] => Array
                                (
                                    [testField] => abc
                                )
                        )
                )
        )
)
----------------------------


[discrete]
==== Deleting a document

Alright, let's go ahead and delete the document that we added previously:

[source,php]
----------------------------
$params = [
    'index' => 'my_index',
    'id'    => 'my_id'
];

$response = $client->delete($params);
print_r($response->asArray());
----------------------------

This syntax is identical to the `get` syntax. The only difference is the 
operation: `delete` instead of `get`. The response confirms the document is 
deleted:

[source,php]
----------------------------
Array
(
    [found] => 1
    [_index] => my_index
    [_type] => _doc
    [_id] => my_id
    [_version] => 2
)
----------------------------


[discrete]
==== Deleting an index

Due to the dynamic nature of {es}, the first document you added automatically 
built an index with some default settings. Delete that index and specify your 
own settings later:

[source,php]
----------------------------
$deleteParams = [
    'index' => 'my_index'
];
$response = $client->indices()->delete($deleteParams);
print_r($response->asArray());
----------------------------

The response:


[source,php]
----------------------------
Array
(
    [acknowledged] => 1
)
----------------------------


[discrete]
==== Creating an index

Now that you are starting fresh (no data or index), add a new index with custom 
settings:

[source,php]
----------------------------
$params = [
    'index' => 'my_index',
    'body' => [
        'settings' => [
            'number_of_shards' => 2,
            'number_of_replicas' => 0
        ]
    ]
];

$response = $client->indices()->create($params);
print_r($response->asArray());
----------------------------

{es} now creates that index with your chosen settings and return an 
acknowledgement:

[source,php]
----------------------------
Array
(
    [acknowledged] => 1
)
----------------------------
